# 平方根を求めるアルゴリズムの実験

平方根を求めるアルゴリズムもいろいろあるので実装、実験してみた。参考文献は[平方根の任意多倍長計算法の例](http://www.kurims.kyoto-u.ac.jp/~kyodo/kokyuroku/contents/pdf/1927-03.pdf)

## 分割統治
要するに GMP の `mpf_sqrt_ui()` で実装されている方法。基本的に整数→整数の演算が前提になっているが、平方根はビット位置の調整をするだけで整数、浮動小数点数の違い実質無くなる。
アルゴリズムをザックリいうと、4 桁の整数の平方根をとって 2 桁にする方法を適用する。

1. 入力全体を n ビットずつ 4 分割する。ただし最上位は n ビットか n - 1 ビットあるようにビットシフト調整する。
1. 上 2 分割分の平方根を求める。これは同じアルゴリズムを再帰的に適用することで求められる。x とする。
1. 2x で余りを割り(商を y とする)、更に y^2 を引く。
  1. 余りが負になったら商を 1 減らす。y^2 の調整もする。

という感じだ。[GMP のドキュメント](https://gmplib.org/manual/Square-Root-Algorithm.html#Square-Root-Algorithm)によるとこれも Karatsuba 法というらしい。

## 実数逆数ニュートン法
[円周率.jp](http://xn--w6q13e505b.jp/method/newton.html) で紹介している方法。特に工夫なく。

## 整数ニュートン法
平方根を有理数近似して、ニュートン法を適用させる。誤差評価がいまいちわからない。

## 固有値法
[参考資料](http://www.kurims.kyoto-u.ac.jp/~kyodo/kokyuroku/contents/pdf/1927-03.pdf)で漸化式方式と呼ばれている方法。2x2 行列の固有ベクトルをうまく使うっぽい。

## 連分数法
同じく[参考資料](http://www.kurims.kyoto-u.ac.jp/~kyodo/kokyuroku/contents/pdf/1927-03.pdf)から。

# 実験結果

2^20 - 2^25 ビットを対象に計算してみた時間はこちら。単位は sec。計算ターゲットは Chudnovsky の公式に出てくる√10005。連分数の数字列の算出など事前準備可能系はなるべく計測時間に含めていない。

|ビット数|mpf|逆数ニュートン|有理数ニュートン|固有値|連分数|
|----|----:|----:|----:|----:|----:|
|2^20|0.008|0.014|0.024|0.029|0.015|
|2^21|0.019|0.031|0.052|0.067|0.035|
|2^22|0.044|0.066|0.135|0.156|0.082|
|2^23|0.100|0.158|0.271|0.345|0.183|
|2^24|0.219|0.374|0.587|0.819|0.424|
|2^25|0.507|0.881|1.289|1.815|0.918|

ちなみに 100 + √10005 = [200, 40] と連分数の繰り返しが少ない。

# 考察

その他特徴としてはニュートン法はやはり 2 次収束なので精度が倍々でしか増えないので微調整しにくい。他の方法は微調整しやすいっぽい。連分数は実数ニュートン法に匹敵する速度でより柔軟な精度調整ができるっぽいので使い勝手がいいかもしれない。

TODO 実験としては、結局除算もするので有理数の形で求めるのが十分に速いなら混ぜてから割るのもいいかも。
